{
  "print": [
    "printの応用系は以下の通りです",
    "print(\"1, 2, 3, sep=\"-\")\"\nsepは複数の値を出力する際の区切り文字を指定します。",
    "print(\"Hello\", end=\"!\")\nendは出力する文字の最後に付ける文字または文字列を指定します。",
    "print(\"log\", file=open(\"log.txt\", \"w\"))\nfileは文字の出力先を指定できます(標準出力以外にもファイルなども指定できる)",
    "print(\"Loading...\", flush=True)\nflushは文字列に含まれている変数の値をリアルタイムで変化させます。"
  ],
  "input": [
    "inputの応用系は以下の通りです",
    "int(input(\"\"))\nint()は受け取った文字列を整数型に変換して変数に格納します。",
    "float(input(\"\"))\nfloat()は受け取った文字列を浮動小数点型に変換して変数に格納します。",
    "必要に応じて.stripや.lower or .upperを()の後につけると小文字に変換できたり大文字小文字を無視できたりします。"
  ],
  "import": [
    "importの応用系は以下の通りです",
    "from ライブラリ import モジュール名\nfromは特定のライブラリを指定し、そこに格納されているモジュールをインポートします。自分で作ったpyファイルの関数をインポートすることも可能です。",
    "import ライブラリ as 別名\nasはモジュールに別の自分だけの名前を付けてインポートします。長いモジュールなどに使うと有効的です。"
  ],
  "if": [
    "ifの応用系は以下の通りです",
    "value = x if condition else y\nこれは三項演算子と呼ばれ、一行で条件分岐を書くことができます。",
    "if 0 < x < 10:\nPythonでは数学のように比較演算子を連結して範囲指定ができます。",
    "if x is None:\nNoneとの比較には==ではなくisを使うのが推奨されています(PEP8)。"
  ],
  "for": [
    "forの応用系は以下の通りです",
    "[i * 2 for i in range(5)]\nリスト内包表記を使うと、for文を使って新しいリストを簡潔に作成できます。",
    "for i, v in enumerate(['a', 'b']):\nenumerateを使うと、インデックス(何番目か)と要素を同時に取得できます。",
    "for a, b in zip([1, 2], [3, 4]):\nzipを使うと、複数のリストをまとめてループ処理できます。"
  ],
  "while": [
    "whileの応用系は以下の通りです",
    "while True:\n条件を常に真にして無限ループを作成し、中でbreakを使って抜け出すパターンがよく使われます。",
    "while data := file.read(1024):\nセイウチ演算子(:=)を使うと、代入と判定を同時に行えて便利です(Python 3.8以降)。"
  ],
  "break": [
    "breakの応用系は以下の通りです",
    "二重ループを一気に抜けたい場合は、フラグ変数を使うか、関数化してreturnするのが一般的です。",
    "Pythonのfor文にはelse節をつけることができ、breakせずにループが終了した場合のみ実行する処理を書けます。"
  ],
  "continue": [
    "continueの応用系は以下の通りです",
    "大きなif文のネスト(入れ子)を避けるために、条件に合わない場合は早めにcontinueで飛ばす「ガード節」として使うとコードが見やすくなります。",
    "例: if not valid:\n    continue"
  ],
  "return": [
    "returnの応用系は以下の通りです",
    "return a, b\nカンマで区切ることで複数の値を返り値として戻すことができます(タプルとして返されます)。",
    "関数内関数をreturnすることで、クロージャ(状態を保持する関数)を作成できます。"
  ],
  "pass": [
    "passの応用系は以下の通りです",
    "class MyError(Exception): pass\n独自のエラー(例外)クラスを作る際、中身が不要な場合にpassだけ書くことがあります。",
    "あえて何もしないことを明示する場合(例: except ValueError: pass)に使います。"
  ],
  "else": [
    "elseの応用系は以下の通りです",
    "for ... else ...\nループがbreakで中断されずに最後まで回りきった時だけ実行されます(検索で見つからなかった場合の処理などに便利)。",
    "try ... except ... else ...\ntryブロックでエラーが起きなかった場合のみ実行したい処理を書きます。"
  ],
  "int": [
    "intの応用系は以下の通りです",
    "int('1010', 2)\n第二引数に基数(何進数か)を指定することで、2進数や16進数の文字列を整数に変換できます。",
    "int(3.99)\n小数をintにすると切り捨てになります(四捨五入ではない点に注意)。"
  ],
  "str": [
    "strの応用系は以下の通りです",
    "f'{value:.2f}'\nf文字列(f-string)を使うと、変数の埋め込みや桁数指定が直感的に行えます。",
    "str.join(['a', 'b', 'c'])\nリストの中身を特定の区切り文字で結合したい場合便利です。"
  ],
  "float": [
    "floatの応用系は以下の通りです",
    "1e-5\n科学技術計算などで使われる指数表記もfloatとして認識されます(0.00001と同じ)。",
    "float('inf')\n無限大を表す値を生成できます。最小値探索の初期値などによく使われます。"
  ],
  "list": [
    "listの応用系は以下の通りです",
    "arr[::-1]\nスライスを使うと、リストの逆順や部分抽出が簡単にできます。",
    "sorted_list = sorted(original_list)\n元のリストを変えずに並び替えた新しいリストを作ります(.sort()は元リストを変更します)。"
  ],
  "len": [
    "lenの応用系は以下の通りです",
    "len(dictionary)\n辞書の場合はキーの数を返します。",
    "自作クラスに __len__ メソッドを定義すると、そのクラスのインスタンスに対してlen()を使えるようになります。"
  ],
  "append": [
    "appendの応用系は以下の通りです",
    "list.extend([4, 5])\nリストに別のリストを結合したい場合はappendではなくextendを使います(appendだとリストの中にリストが入ってしまいます)。",
    "list.insert(0, value)\n末尾ではなく特定の位置(この場合は先頭)に追加したい場合はinsertを使います。"
  ],
  "remove": [
    "removeの応用系は以下の通りです",
    "value = list.pop(index)\n要素を削除しつつ、その値を取得したい場合はpopを使います。引数なしだと末尾を取り出します。",
    "list.clear()\nリストの中身を全て消去したい場合に使います。"
  ],
  "dict": [
    "dictの応用系は以下の通りです",
    "{x: x**2 for x in range(5)}\nリストと同様に、辞書も内包表記で作ることができます。",
    "dict(zip(keys, values))\nキーのリストと値のリストから辞書を一発で作成するテクニックです。"
  ],
  "get": [
    "getの応用系は以下の通りです",
    "value = d.setdefault(key, default)\nキーがあればその値を取得し、なければデフォルト値を登録してから取得します。",
    "辞書のキーが存在するか確認するだけなら 'key in d' と書くのがPythonらしい書き方です。"
  ],
  "keys": [
    "keysの応用系は以下の通りです",
    "for k, v in d.items():\nキーだけでなく値も同時にループ処理したい場合はitems()を使います。",
    "list(d.values())\n値だけを取り出してリスト化したい場合はvalues()を使います。"
  ],
  "def": [
    "defの応用系は以下の通りです",
    "def func(a, b=10):\nデフォルト引数を指定すると、呼び出し時に省略可能な引数を作れます。",
    "def func(*args, **kwargs):\n引数の数が決まっていない(可変長引数)関数を定義する際に使います。"
  ],
  "lambda": [
    "lambdaの応用系は以下の通りです",
    "sorted(data, key=lambda x: x['age'])\n辞書のリストを特定のキーでソートしたい場合など、使い捨ての関数として大活躍します。",
    "map(lambda x: x*2, numbers)\n全ての要素に関数を適用したい場合などに使います(最近は内包表記の方が好まれる傾向もあります)。"
  ],
  "open": [
    "openの応用系は以下の通りです",
    "open('file.txt', 'r', encoding='utf-8')\n文字化けを防ぐため、テキストファイルを扱う際はencoding指定が強く推奨されます。",
    "open('image.png', 'rb')\n画像や音声などのバイナリファイルを扱う際はモードに'b'を付けます。"
  ],
  "read": [
    "readの応用系は以下の通りです",
    "lines = f.readlines()\nファイルの中身を1行ことのリストとして読み込みます。",
    "line = f.readline()\nメモリ節約のため、1行ずつ読み込みたい場合に使います。"
  ],
  "write": [
    "writeの応用系は以下の通りです",
    "f.writelines(lines)\nリストに入っている複数の文字列をまとめて書き込みます(改行は自動では入らないので注意)。",
    "追記モード 'a' でopenすると、既存の内容を消さずに末尾に追加できます。"
  ],
  "with": [
    "withの応用系は以下の通りです",
    "with open('a.txt') as f1, open('b.txt') as f2:\nカンマ区切りで複数のファイルを同時に開くことができます。",
    "自作クラスに __enter__ と __exit__ を定義すると、with文に対応させることができます。"
  ],
  "try": [
    "tryの応用系は以下の通りです",
    "try ... except ... finally\nエラーが起きても起きなくても必ず実行したい処理(ファイルのクローズなど)をfinallyに書きます。",
    "WebスクレイピングやAPI通信など、外部要因で失敗しやすい処理には必須です。"
  ],
  "except": [
    "exceptの応用系は以下の通りです",
    "except (ValueError, TypeError) as e:\n複数のエラーをまとめて捕捉したり、 'as e' でエラー内容を変数として受け取ってログに出力したりできます。",
    "except Exception:\n全てのエラーを捕捉できますが、予期せぬバグを見逃す原因になるため、乱用は避けて具体的なエラーを指定しましょう。"
  ],
  "class": [
    "classの応用系は以下の通りです",
    "class Child(Parent):\n他のクラスの機能を継承して、新しいクラスを作ることができます。",
    "super().__init__()\n親クラスの初期化メソッドを呼び出す際に使います。"
  ]
}